/**********************************************************************************************/
// Created by Mahmoud Atef on Saturday Oct 14, 2017.
/**********************************************************************************************/
// Global Constants
#define GREY_LEVELS 256

// optimizatino algorithms
#include "pso.h"
#include "cs.h"
#include "abc.h"
#include "otsudp.h"

#include <iostream>
#include <algorithm>    // std::sort

#include <experimental/filesystem>
namespace fs = std::experimental::filesystem;

#include <math.h>       /* signbit, sqrt */

#include<vector>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
//#include <getopt.h>

#include <chrono>
using namespace std::chrono;
/*#include <ratio>
#include <ctime>
*/
// parameters
std::string alg;            // specified algorithm
std::string pathname;    // input.model and output.ca
int K;                 // no of clusterss
Otsu *pb;
int totalElapsedIterationCount;
//bool generateLabelImage;
int verbosity;

enum class DumpType {NODUMP,
                     SOLUTION_QUALITY_DUMP,
                     SUBJECTIVE_EVALUTION_DUMP,
                     OPTIMAL_THRESHOLDS_DUMP,
                     OT_VARIANCE_DUMP,
                     SOLUTION_PERFORMANCE_DUMP}; 

DumpType dt;
/*
    commond:
    app algorithm pathname.model
        algorithm = cpso | ctvac | cclpso | capso | cdmspso (conventional version)
                  = dpso | dtvac | dclpso | dapso | ddmspso (discrete version)
    output:
        the covering array that is generated by specified algorithm
        and the result is saved in pathname.ca
*/

int parseOptions(int argc, char **argv)
{
    int c;
    int d;
    while ((c = getopt (argc, argv, "k:a:d:o:v:")) != -1)
        switch (c)
          {
          case 'v':
            verbosity =  atoi(optarg);
            break;
          case 'o':
          {
            //generateLabelImage = true;
            d = atoi(optarg);
            switch (d)
            {
            case 0:
              dt = DumpType::NODUMP;
              break;
            case 1:
              dt = DumpType::SOLUTION_QUALITY_DUMP;
              break;
            case 2:
              dt = DumpType::SUBJECTIVE_EVALUTION_DUMP;
              break;
            case 3:
              dt = DumpType::OPTIMAL_THRESHOLDS_DUMP;
              break;
            case 4:
              dt = DumpType::OT_VARIANCE_DUMP;
              break;
            case 5:
              dt = DumpType::SOLUTION_PERFORMANCE_DUMP;
              break;
            default:
              abort ();
            }
              cout << "dump option: " << d << endl;
            break;
          }
          case 'k':
            K = atoi(optarg);
            if(verbosity >= 2) cout << "K: " << K << endl;
           // aflag = 1;
            break;
          case 'a':
          {
            // get algorithm
            alg = optarg;
         //   cout << "alg: " << alg << endl;
            int algorithmCounts = 6;
            string algs[] = { "hcoclpso", "cscm" , "csm", "ccqpso", "mabc", "otsudp"};
            if (find(algs, algs + algorithmCounts, alg) == algs + algorithmCounts)
            {
                cout << "Invalid parameter: algorithm. Failed." << endl;
                return 0;
            }
            break;
          }
          case 'd':
            pathname = optarg;
            break;
          case '?':
            if (optopt == 'c')
              fprintf (stderr, "Option -%c requires an argument.\n", optopt);
            else if (isprint (optopt))
              fprintf (stderr, "Unknown option `-%c'.\n", optopt);
            else
              fprintf (stderr,
                       "Unknown option character `\\x%x'.\n",
                       optopt);
            return 1;
          default:
            abort ();
          }
    return 1;
/*
    for (index = optind; index < argc; index++)
        printf ("Non-option argument %s\n", argv[index]);
    
    return 1;*/

/*
    // TODO: should return 0 if file is not found
    return 1;*/
}

int main(int argc, char **argv)
{
    srand((unsigned int)time(0));
    totalElapsedIterationCount = 0;
    
   // generateLabelImage = false;
    dt = DumpType::NODUMP;
	int filecount=0;
    int populationCount = 20;
    int iterationCount = 10000;
    verbosity = 0;

    if (!parseOptions(argc, argv))
        return 0;

 //   auto t1 = time(0);
    int par = K-1;
    int *val = new int[par];
    // set value limits for each threshold
    for(int i = 0; i < par; i++){
        val[i] = GREY_LEVELS - (K - 2) + i ;
    }

    string result_dir ;
    
    if(dt == DumpType::SOLUTION_QUALITY_DUMP){
        result_dir = pathname + "_" + alg + "_result_" +  to_string(K);
        if(verbosity >= 4) cout << "result_dir: " << result_dir << endl;
        fs::create_directory(result_dir);
        if(verbosity >= 4)  cout << "Current Path: " << fs::current_path() << endl;
    }
    else if(dt == DumpType::SUBJECTIVE_EVALUTION_DUMP){
        result_dir = pathname + "_algOut" ;
        if(verbosity >= 4) cout << "result_dir: " << result_dir << endl;
        if(!fs::exists(result_dir)) fs::create_directory(result_dir);  
    }
    else if(dt == DumpType::OPTIMAL_THRESHOLDS_DUMP){
        result_dir = pathname + "_" + alg + "_result_optimal_thresholds_" +  to_string(K);
        if(verbosity >= 4) cout << "result_dir: " << result_dir << endl;
        fs::create_directory(result_dir);        
    }
    else if(dt == DumpType::OT_VARIANCE_DUMP){
        // path to Itrative DP threshold values, for benchmarking purposes
        result_dir = pathname + "_otsudp_result_optimal_thresholds_" +  to_string(K);
        if(verbosity >= 4) cout << "result_dir: " << result_dir << endl;
        // don't create the directory as it will be exists
    }

//    bool isDPAlgorithm = (alg == "otsudp");
    double elapsedTime = 0.0;
    double objFun = 0.0;
    double optThresVariance = 0.0;
    int optimalTestCases = 0;
//    int Klist[] = {2,3};
 //   string algList [] = {"otsudp","hcoclpso"}; 
  //  for(int m = )
	for(auto & p : fs::directory_iterator(pathname)){
		filecount++;

		std::string filename = (p.path()).string(); 
        if(verbosity >= 2) std::cout << "Processing image: " <<  filename << std::endl;
        // initialize IUT
        pb = new Otsu(par, val, filename,verbosity);
        optAlg *oAlg = NULL;
        if (alg == "hcoclpso"){ // hybrid cooperative comprehensive learning PSO
            float IntialInteriaWeight = 0.9;
            float intertiaSlope = 2.5e-4;
            uint8_t maxVelocity = 6;
            int ci = 2;
            float selectionProbability = .2;
            int Sreplace = 10;
            int stagnationLimit = 3;
            PsoVariant psoAlgo = PsoVariant::HCOCLPSO;

            oAlg = new Pso(  pb,
                              populationCount,
                              iterationCount,
                              verbosity,
                              psoAlgo,
                              IntialInteriaWeight,
                              intertiaSlope,
                              maxVelocity,
                              ci,
                              selectionProbability,
                              stagnationLimit,
                              Sreplace);
        }
        else if (alg == "ccqpso"){ // Dynamic-Context Cooperative Quantum PSO (Li 2015)
            PsoVariant psoAlgo = PsoVariant::CCQPSO;
            oAlg = new Pso(  pb,
                              populationCount,
                              iterationCount,
                              verbosity,
                              psoAlgo
                              );
        }

        else if (alg == "csm"){ // Cuckoo Search with Mantegna’s method for levy flight
            float alienEggDiscoveryRate = 0.25;
            oAlg = new Cs(  pb,
                            populationCount,
                            iterationCount,
                            verbosity,
                            alienEggDiscoveryRate);
        }
        else if (alg == "cscm"){ // Cuckoo Search with McCulloch’s method for levy flight
            float alienEggDiscoveryRate = 0.25;
            bool enableMcCullochMethod = true;
            oAlg = new Cs(  pb,
                            populationCount,
                            iterationCount,
                            verbosity,
                            alienEggDiscoveryRate,
                            enableMcCullochMethod);
        }
        else if(alg == "otsudp"){
            oAlg = new OtsuDp(  pb,
                                verbosity);
        }
        else
        {
            cout << "Algorithm error. Failed." << endl;
            return 0;
        }
        
       // auto start = chrono::steady_clock::now();
        high_resolution_clock::time_point t1 = high_resolution_clock::now();
        oAlg->evolve();
        high_resolution_clock::time_point t2 = high_resolution_clock::now();

        //duration<double> time_span = duration_cast<duration<double>>(t2 - t1);

       // std::cout << "It took me " << time_span.count() << " seconds.";
        //std::cout << std::endl;
    //    auto end = chrono::steady_clock::now();
   //     auto diff = end - start;
    //    assert((diff).count() >=0.0);

        elapsedTime +=  chrono::duration_cast<chrono::microseconds> (t2-t1).count();
       // elapsedTime +=  time_span.count();
        totalElapsedIterationCount += oAlg->getElapsedIterations();
        objFun += oAlg->gfit;
        
        if(dt == DumpType::SOLUTION_QUALITY_DUMP || dt == DumpType::SUBJECTIVE_EVALUTION_DUMP){
            string fn = filename.substr (pathname.length() + 1);     //
            if(verbosity >= 6) cout << "fn: " << fn << endl;
            size_t pos = fn.find_last_of(".");      // position of "." in fn
            fn = fn.substr (0,pos);
            if(verbosity >= 6) cout << "fn: " << fn << endl;
            if(dt == DumpType::SOLUTION_QUALITY_DUMP){
                fn = result_dir + "/"+ fn + ".csv";
            }
            else {
                fn = result_dir + "/"+ fn + "_" + alg + "_" +  to_string(K) + ".csv";
            }
            if(verbosity >= 4) cout << "fn: " << fn << endl;
            
            pb->generateLabeledImage(oAlg->cv, fn);
        }
        else if (dt == DumpType::OPTIMAL_THRESHOLDS_DUMP || dt == DumpType::OT_VARIANCE_DUMP){
          //  cout << "dump optimal thresholds" << endl;
            string fn = filename.substr (pathname.length() + 1);     //
            if(verbosity >= 6) cout << "fn: " << fn << endl;
            size_t pos = fn.find_last_of(".");      // position of "." in fn
            fn = fn.substr (0,pos);
            if(verbosity >= 6) cout << "fn: " << fn << endl;
            fn = result_dir + "/"+ fn + "_ot_.txt";
            if(verbosity >= 6) cout << "fn: " << fn << endl;
            if (dt == DumpType::OPTIMAL_THRESHOLDS_DUMP) {
                oAlg->dumpOptThrslds(fn);
            }
            else{
                double var;
                bool findoptimal = oAlg->assessThrs(fn,var);
                optThresVariance += var;
                if(findoptimal){
                    optimalTestCases ++;
                }
            }
        }
        
     /*   else if(dt == DumpType::SUBJECTIVE_EVALUTION_DUMP){
        }*/
        delete oAlg;
        delete pb;
    }
    elapsedTime = elapsedTime/(double)filecount/1000 ;
    objFun = objFun/(double)filecount;
    double avItrCnt = (double)totalElapsedIterationCount / (double)filecount;
    optThresVariance = optThresVariance/(double)filecount;
    if(verbosity >= 0){
        cout << "No. of processed images: " << filecount << endl;
        cout << "Average no. of iterations: " << avItrCnt << endl;
        cout << "Elapsed Time: " <<  elapsedTime<< " ms" << endl;
        cout << "Objective function: " << objFun << endl;
        cout << "optimal Test Cases found: " << optimalTestCases << endl;
        cout << "optimal thresholds standard error: " << optThresVariance << endl;
		cout << "time measurement resolution: " << (double)chrono::high_resolution_clock::period::num/(double)chrono::high_resolution_clock::period::den * 1e6 << " microsecond"<< endl;
    }
    
    if (dt == DumpType::OT_VARIANCE_DUMP){
        cerr << " " << optThresVariance << endl;
    }        
    else if (dt == DumpType::SOLUTION_PERFORMANCE_DUMP){
        cerr << " "  << elapsedTime << endl;
    }        

/*
    if(isDPAlgorithm){
        cerr << " & " << K << " & " << std::setprecision (3) << elapsedTime << " & " << std::setprecision (6) << objFun << endl;
    }
    else{
        cerr << " & " << std::setprecision (3) << elapsedTime  << " & "<< std::setprecision (6)  << objFun << " & " << round(avItrCnt) << endl;
    }
*/     
    
	delete [] val;
}
